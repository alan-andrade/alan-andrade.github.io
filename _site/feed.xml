<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Alan Andrade</title>
<generator uri="https://github.com/jekyll/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://alan-andrade.github.io/feed.xml" />
<link rel="alternate" type="text/html" href="http://alan-andrade.github.io" />
<updated>2015-10-12T01:40:08-07:00</updated>
<id>http://alan-andrade.github.io/</id>
<author>
  <name>Alan Andrade</name>
  <uri>http://alan-andrade.github.io/</uri>
  <email>alan.andradec+website@gmail.com</email>
</author>


  

<entry>
  <title type="html"><![CDATA[Phoenix in 10 minutes]]></title>
  <link rel="alternate" type="text/html" href="http://alan-andrade.github.io/PhoenixIn10Minutes/" />
  <id>http://alan-andrade.github.io/PhoenixIn10Minutes</id>
  <published>2015-10-10T22:43:25-07:00</published>
  <updated>2015-10-10T22:43:25-07:00</updated>
  <author>
    <name>Alan Andrade</name>
    <uri>http://alan-andrade.github.io</uri>
    <email>alan.andradec+website@gmail.com</email>
  </author>
  <content type="html">
    &lt;p&gt;So you’ve been hearing good stuff about Elixir and Phoenix but you
haven’t had a chance to check it out ? Let’s fix that by building an API
within 10 minutes. The server will echo the parameters of the request
with json format. Don’t go to lunch yet ! &lt;img class=&quot;emoji&quot; title=&quot;:open_hands:&quot; alt=&quot;:open_hands:&quot; src=&quot;https://assets.github.com/images/icons/emoji/unicode/1f450.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;resources&quot;&gt;Resources&lt;/h1&gt;

&lt;h2 id=&quot;erlang&quot;&gt;Erlang&lt;/h2&gt;

&lt;p&gt;In order to use Elixir, we need to install Erlang first because Elixir
runs on top of Erlang’s virtual machine. Install Erlang 18.0 from
&lt;a href=&quot;https://www.erlang-solutions.com/downloads/download-erlang-otp&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;elixir&quot;&gt;Elixir&lt;/h2&gt;

&lt;p&gt;Brew it with &lt;code&gt;brew update &amp;amp;&amp;amp; brew install elixir&lt;/code&gt; or install it from &lt;a href=&quot;http://elixir-lang.org/install.html#distributions&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;phoenix&quot;&gt;Phoenix&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Install ‘hex’, the dependency manager &lt;code&gt;mix local.hex&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Install Phoenix &lt;code&gt;mix archive.install
https://github.com/phoenixframework/phoenix/releases/download/v1.0.3/phoenix_new-1.0.3.ez&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Elixir comes with a tool called mix which is like ruby’s rake, it runs
predefined tasks or “recipes”.  Hex on the other hand, ensures that
every library that we use is compatible with each other. Hex plays the
role of Bundler or NPM, but for Elixir.&lt;/p&gt;

&lt;h1 id=&quot;project-creation&quot;&gt;Project creation&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;mix phoenix.new echoAPI --no-brunch --no-ecto --no-html&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Create the project under the folder “echoAPI”.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--no-brunch&lt;/code&gt; Skips the asset manager for front end stuff such as images
and javascripts.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--no-ecto&lt;/code&gt; Skips the database and the model layer.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--no-html&lt;/code&gt; Skips the generation of any html.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;the-plan&quot;&gt;The plan&lt;/h1&gt;

&lt;p&gt;Phoenix follows the MVC pattern and comes with conventions
similar to those present in rails or ember. Don’t worry if you haven’t
used any of those frameworks, I’ll explain the general idea and you’ll
be able to follow along.&lt;/p&gt;

&lt;p&gt;To build our useful echo endpoint, we’re going to work on two key components.
Remember that this app doesn’t need any database so the “Model” is out
of the “MVC”&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. We need to define a &lt;strong&gt;controller&lt;/strong&gt; that can handle the high
volume of incoming requests and also get it to render json.
We’ve tackled the 3 letters out of MVC, but to get this to work, we need
to define a new entry on the application’s &lt;strong&gt;router&lt;/strong&gt;. The routes are
like a map that hold information of which controller will process what
endpoint. e.g. &lt;code&gt;/api/echo&lt;/code&gt; should be handled by the controller
“EchoController”.&lt;/p&gt;

&lt;p&gt;Let’s begin ! &lt;img class=&quot;emoji&quot; title=&quot;:muscle:&quot; alt=&quot;:muscle:&quot; src=&quot;https://assets.github.com/images/icons/emoji/unicode/1f4aa.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;controller&quot;&gt;Controller&lt;/h1&gt;

&lt;p&gt;Create a new file under &lt;code&gt;web/controllers&lt;/code&gt; and name it
&lt;code&gt;echo_controller.ex&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The controller will process the request and should return a json with
all the parameters sent in the request. The file should look like this.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span class=&quot;kd&quot;&gt;defmodule&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EchoAPI.EchoController&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;kn&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EchoAPI.Web&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:controller&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;defmodule&lt;/code&gt; Is used to define a new module in Elixir.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EchoAPI.EchoController&lt;/code&gt; is the name of the controller prefixed by
the namespace of the application.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;use EchoApi.Web :controller&lt;/code&gt; is where something like inheritance
happens. This will inject code that comes from `web/web.ex’ which
  gives this module the interface and features of a controller.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;def index(conn, params)&lt;/code&gt; is a function definition which will called
when the request comes in.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;conn&lt;/code&gt; is the current connection.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;params&lt;/code&gt; are the request parameters.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;json&lt;/code&gt; Is a method defined in &lt;code&gt;Phoenix.Controller&lt;/code&gt; which sends a json
reponse with the second argument as the body.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This controller is ready to answer requests and echo the parameters
back. Let’s connect it to the router.&lt;/p&gt;

&lt;h1 id=&quot;routes&quot;&gt;Routes&lt;/h1&gt;

&lt;p&gt;Open &lt;code&gt;web/router.ex&lt;/code&gt;, it should look like this.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span class=&quot;kd&quot;&gt;defmodule&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EchoAPI.Router&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;kn&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EchoAPI.Web&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:router&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pipeline&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:api&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;plug&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:accepts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;json&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;/api&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EchoAPI&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pipe_through&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:api&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;pipeline&lt;/code&gt; is a wrapper for operations that transform the request.
Similar concept to Rack.&lt;/li&gt;
  &lt;li&gt;a &lt;code&gt;plug&lt;/code&gt; is an interface for operations that will run inside of a
pipeline. This is like the Rack Middleware.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;scope&lt;/code&gt; is used to group endpoints and the second argument is an
alias. This means that anywhare under scope, you can use your modules
without typing the namespace. e.g. “EchoAPI.EchoController” becomes
“EchoController”.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;pipe_through&lt;/code&gt; is making sure that anything under that group, goes
through the the set of operations of the pipeline “api”.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s connect out new controller !&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# ...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;/api&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EchoAPI&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pipe_through&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:api&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;/echo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EchoController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:index&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;get&lt;/code&gt; is a macro that maps the controller to a &lt;code&gt;GET&lt;/code&gt; request.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;/echo&lt;/code&gt; is the endpoint and since its under the “/api” scope, its
final shape is “/api/echo”&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EchoController&lt;/code&gt; is the name of the controller that will serve.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;:index&lt;/code&gt; is the function of the controller that will take care of
things.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;play&quot;&gt;Play&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;Run you application with &lt;code&gt;mix phoenix.server&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Use curl or a browser to point to the new endpoint. &lt;code&gt;curl
localhost:4000/api/echo\?foo=bar&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Feel proud. &lt;img class=&quot;emoji&quot; title=&quot;:godmode:&quot; alt=&quot;:godmode:&quot; src=&quot;https://assets.github.com/images/icons/emoji/godmode.png&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;If you come from the Rails world, Phoenix will look quite familiar.&lt;/p&gt;

&lt;p&gt;Most of the framework’s ideas can be traced back to Rails and friends.
This helps to understand more about how things work and connect the
dots.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Not having a database doesn’t mean our app doesn’t have a model.  I made an exception and tight the two concepts together. It’s perfectly normal to have “Models” that aren’t dependant on a database. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

    &lt;p&gt;&lt;a href=&quot;http://alan-andrade.github.io/PhoenixIn10Minutes/&quot;&gt;Phoenix in 10 minutes&lt;/a&gt; was originally published by Alan Andrade at &lt;a href=&quot;http://alan-andrade.github.io&quot;&gt;Alan Andrade&lt;/a&gt; on October 10, 2015.&lt;/p&gt;
  </content>
</entry>

</feed>
